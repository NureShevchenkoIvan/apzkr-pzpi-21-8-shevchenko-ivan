Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система моніторингу землі для сільськогосподарських потреб


Студент гр. ПЗПІ-21-8	__________________ Шевченко І.В.
	(підпис)
Керівник роботи	__________________ ст. викл. Сокорчук І.П.
	(підпис)
	Роботу захищено «__»__________2024 р.
	з оцінкою __________________________

Комісія:	__________________ доц. Лещинський В. О.
	(підпис)
	__________________ доц. Лещинська І. О.
	(підпис)
	__________________ ст. викл. Сокорчук І.П.
	(підпис)

Харків
2024 р. 
Харківський національний університет радіоелектроніки 
 
Факультет комп’ютерних наук Кафедра програмної інженерії  Спеціальність 121 – Інженерія програмного забезпечення  
Курс 3 Семестр 6  
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                              Шевченку Івану Валерійовичу                               _                     
1. Тема роботи: «Програмна система моніторингу землі для сільськогосподарських потреб»
2. Термін узгодження завдання курсової роботи «_1_»___квітня___ 2024 р.
3. Термін здачі студентом закінченої роботи «_7_»___червня__ 2024 р.  
4. Вихідні дані до проекту (роботи): В програмній системі передбачити: моніторинг землі, перегляд даних з сенсорів, отримання рекомендацій, додавання користувачів та їх редагування. Використовувати ОС Windows 10 або 11, СУБД MongoDB, середовище розробки Microsoft Visual Studio 2022
5. Зміст пояснювальної записки (перелік питань, що належить розробити):
Вступ, аналіз предметної області, постановка задачі, проектування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): Deployment Diagram, Use Case Diagram, Entity–Relationship Model, State Diagram, Interaction Overview Diagram, Activity Diagram, Component Diagram.
 
КАЛЕНДАРНИЙ ПЛАН	


№	Основні етапи виконання проєкту в рамках лабораторних робіт	Термін виконання
етапів	Примітка
1	Функціональна специфікація 
програмного проєкту	06.04.2024 
	виконано
2	Проектування програмного 
проєкту	21.04.2024 	виконано
3	Кодування програмного проєкту	28.05.2024	виконано
4	Оформлення пояснювальної записки	03.06.2024	виконано
5	Захист курсової роботи	08.06.2024	виконано

Дата видачі завдання «__1__»____квітня____2024 р.  
Керівник 				 ______________ ст. викл. Сокорчук І.П.
(підпис)  

Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-8			 _____________		Шевченко І. В. 
         (підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 87 с., 22 рис., 2 табл., 4 додатки, 8 джерел.
NODE.JS, REACT, MONGODB, IOT, ARDUINO, ESP32, СЕНСОРИ, БАЗА ДАНИХ, ВІЗУАЛІЗАЦІЯ ДАНИХ, РЕКОМЕНДАЦІЙНА СИСТЕМА, МОНІТОРИНГ ҐРУНТУ, СІЛЬСЬКЕ ГОСПОДАРСТВО, RESPONSIVE ДИЗАЙН, REST API, JWT АВТЕНТИФІКАЦІЯ. 
Метою роботи є розробка програмної системи моніторингу землі для сільськогосподарських потреб, яка включає збір даних з IoT-пристроїв, їх обробку на сервері, зберігання в базі даних та візуалізацію у веб-інтерфейсі з використанням технологій Node.js, React, MongoDB та Arduino. 
До методів дослідження, що були використані, входять аналіз предметної області сільського господарства, проектування архітектури системи, розробка IoT-пристроїв для збору даних, створення серверної частини та клієнтського інтерфейсу. Застосовано підхід REST API для взаємодії між компонентами системи. Автентифікація користувачів реалізована за допомогою JSON Web Tokens (JWT). Для зберігання даних використано нереляційну базу даних MongoDB з ODM Mongoose. Клієнтська частина розроблена з використанням бібліотеки React та компонентів Material-UI. Програмування IoT-пристроїв здійснювалось на базі Arduino framework та мікроконтролера ESP32. 
В результаті отримана програмна система моніторингу землі для сільськогосподарських потреб, яка дозволяє збирати дані про вологість, температуру та рівень поживних речовин ґрунту, візуалізувати їх у вигляді графіків, та надавати рекомендації щодо догляду за культурами. Система підтримує реєстрацію та автентифікацію користувачів, управління сенсорами та культурами, фільтрацію даних за різними параметрами. Реалізовано багатомовний інтерфейс з підтримкою української та англійської мов.  
ЗМІСТ


Вступ	7
1 Аналіз предметної області	8
1.1 Бізнес-вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес-цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2 Концепція рішення	11
1.2.1 Окреслення концепції	11
1.2.2 Головна функціональність	12
1.2.3 Припущення та залежності	13
1.3 Рамки та обмеження	14
1.3.1 Рамки первинного випуску	14
1.3.2 Рамки наступних випусків	15
1.3.3 Обмеження та винятки	16
1.4 Бізнес-контекст	17
1.4.1 Профілі зацікавлених сторін	17
1.4.2 Пріоритети проєкту	18
1.4.3 Робоче середовище	18
2 Опис архітектури системи	20
2.1 Опис архітектури серверної частини	20
2.2 Опис архітектури IoT частини	24
2.3 Опис архітектури клієнтської частини	29
3 Проєктування бази даних	34
4 Опис програми	37
4.1 Виклик і завантаження	37
4.2 Призначення і логічна структура	38
4.3 Опис програмної реалізації	39
Висновки	44
Перелік джерел посилання	45
Додаток А Код серверної частини	46
Додаток Б Код IoT частини	61
Додаток В Код клієнтської частини	65
Додаток Г Результат перевірки на наявність плагіату	87
 
ВСТУП


У сучасному світі сільське господарство стикається з численними викликами, такими як зміна клімату, обмеженість ресурсів та зростаючий попит на продукти харчування. В цих умовах ефективне управління сільськогосподарськими угіддями стає критично важливим. Технологічний прогрес, зокрема у сфері Інтернету речей та аналізу даних, відкриває нові можливості для оптимізації сільськогосподарського виробництва. 
Саме тому розробка програмних систем, які допомагають аграріям приймати обґрунтовані рішення на основі актуальних даних про стан ґрунту та посівів, набуває все більшої актуальності. Такі системи дозволяють автоматизувати процес збору та аналізу даних, що значно підвищує ефективність управління сільськогосподарськими угіддями. 
"Програмна система моніторингу землі для сільськогосподарських потреб" є відповіддю на ці виклики. Вона об'єднує в собі можливості IoT-пристроїв для збору даних про стан ґрунту, потужності серверної обробки для аналізу цих даних та зручний веб-інтерфейс для візуалізації результатів і надання рекомендацій. 
Ця система дозволяє аграріям в режимі реального часу отримувати дані про вологість, температуру та рівень поживних речовин у ґрунті. На основі цих даних система генерує рекомендації щодо поливу та внесення добрив, що допомагає оптимізувати використання ресурсів та підвищити врожайність. 
Таким чином, метою роботи є розробка комплексної програмної системи моніторингу землі для сільськогосподарських потреб, яка включає в себе IoT-пристрої для збору даних, серверну частину для їх обробки та зберігання, а також веб-інтерфейс для візуалізації, управління даними та отримання рекомендацій. Ця система має значно полегшити роботу аграріїв, допомогти їм приймати обґрунтовані рішення та підвищити ефективність сільськогосподарського виробництва.  
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості 


Ринок сільськогосподарських технологій активно розвивається, і існує значний попит на інноваційні рішення для підвищення ефективності землеробства. Система "SoilMonitoring" заповнює важливу нішу, надаючи фермерам інструмент для точного моніторингу стану ґрунту та отримання рекомендацій щодо догляду за культурами. 
Наша система відрізняється від існуючих рішень наступними перевагами:
-	Комплексний підхід: моніторинг вологості, температури та рівня поживних речовин в одній системі 
-	Інтеграція IoT-пристроїв для автоматичного збору даних 
-	Персоналізовані рекомендації на основі аналізу даних 
-	Доступність через веб-інтерфейс
-	Підтримка кількох мов для виходу на міжнародний ринок 
"SoilMonitoring" відповідає сучасним трендам precision farming та sustainable agriculture, що робить її привабливою для широкого кола сільськогосподарських підприємств. 






1.1.2	Бізнес-цілі та критерії успіху


Бізнес цілі:
1.	Досягти 10,000 активних користувачів системи протягом першого року після запуску. 
2.	Збільшити ефективність використання води у користувачів системи на 20% протягом перших 6 місяців використання. 
3.	Підвищити врожайність культур користувачів в середньому на 15% протягом першого сезону використання системи. 
4.	Досягти рівня утримання клієнтів 80% після першого року використання. 
5.	Вийти на ринки щонайменше 3 країн протягом перших двох років роботи. 
Критерії успіху: 
1.	Позитивні відгуки від 85% користувачів щодо зручності використання системи. 
2.	Зменшення витрат на добрива у користувачів на 10-15% завдяки оптимізації їх внесення. 
3.	Досягнення окупності інвестицій (ROI) для користувачів протягом одного сільськогосподарського сезону.
4.	Отримання не менше двох галузевих нагород за інноваційність протягом перших трьох років роботи.




1.1.3	Потреби клієнтів або ринку


-	Автоматизований збір даних про стан ґрунту для зменшення ручної праці та підвищення точності вимірювань. 
-	Централізоване зберігання та обробка даних для зручного доступу та аналізу. 
-	Візуалізація даних у вигляді графіків та діаграм для легкого сприйняття інформації. 
-	Отримання персоналізованих рекомендацій щодо поливу та внесення добрив на основі аналізу даних. 
-	Доступ до інформації з різних пристроїв (ПК, планшети, смартфони) для зручності використання в польових умовах. 
-	Можливість управління декількома полями або ділянками в рамках однієї системи. 
-	Інтеграція з існуючими сільськогосподарськими системами та обладнанням. 
-	Підтримка кількох мов для використання системи в різних країнах. 
-	Захист даних та конфіденційність інформації користувачів.
-	Можливість експорту даних для подальшого аналізу або звітності.






1.1.4	Бізнес-ризики


1.	Конкуренція: Ризик появи подібних систем від великих агротехнологічних компаній. Пом'якшення: Постійне вдосконалення функціоналу та фокус на потреби клієнтів. 
2.	Технічні збої: Ризик втрати даних або некоректної роботи системи. Пом'якшення: Впровадження надійних систем резервного копіювання та моніторингу. 
3.	Прийняття користувачами: Ризик низького рівня адаптації через консервативність аграрного сектору. Пом'якшення: Проведення навчальних програм та демонстрацій, створення простого інтуїтивного інтерфейсу. 
4.	Точність рекомендацій: Ризик надання неточних рекомендацій, що може призвести до втрати довіри. Пом'якшення: Постійне вдосконалення алгоритмів, співпраця з агрономами та науковими установами. 
5.	Регуляторні обмеження: Ризик зміни законодавства щодо збору та обробки даних у різних країнах. Пом'якшення: Моніторинг законодавчих змін та гнучка адаптація системи до нових вимог.


1.2	Концепція рішення
1.2.1	Окреслення концепції 


"SoilMonitoring" - це інноваційна система моніторингу ґрунту, яка трансформує підхід до сільського господарства, надаючи фермерам точні дані та інтелектуальні рекомендації для оптимізації вирощування культур. Наша мета - створити світ, де кожен аграрій має доступ до передових технологій для підвищення врожайності, економії ресурсів та збереження навколишнього середовища. 
Ми прагнемо стати провідним інструментом для precision farming, який дозволить фермерам приймати обґрунтовані рішення на основі реальних даних, підвищуючи ефективність сільськогосподарського виробництва та сприяючи сталому розвитку аграрного сектору.


1.2.2	Головна функціональність


MF-1: Інтегрована система збору даних з IoT-пристроїв для вимірювання вологості, температури та рівня поживних речовин у ґрунті. 
MF-2: Централізована платформа для зберігання, обробки та візуалізації даних про стан ґрунту. 
MF-3: Інтелектуальна система рекомендацій щодо поливу та внесення добрив на основі аналізу даних сенсорів та специфіки культур. 
MF-4: Веб-інтерфейс та мобільний додаток для зручного доступу до даних та управління системою. 
MF-5: Функціонал управління різними ділянками та культурами в рамках однієї системи. 
MF-6: Багатомовний інтерфейс з підтримкою української та англійської мов.
MF-7: Система сповіщень та попереджень про критичні зміни стану ґрунту. 
MF-8: Інструменти для експорту та імпорту даних для інтеграції з іншими сільськогосподарськими системами. 
MF-9: Адміністративний модуль для управління користувачами та налаштування системи. 
MF-10: Адаптивний дизайн для коректного відображення на різних пристроях. 
MF-11: Захист даних згідно з GDPR та іншими стандартами.


1.2.3	Припущення та залежності


Припущення: 
1.	Фермери мають доступ до стабільного інтернет-з'єднання для передачі даних з IoT-пристроїв та доступу до веб-інтерфейсу. 
2.	Користувачі мають базові навички роботи з комп'ютером та мобільними пристроями. 
3.	Існує зростаючий попит на технології precision farming серед аграріїв. 
4.	Законодавство різних країн дозволяє збір та обробку даних про стан ґрунту. 
Залежності: 
1.	Надійність та точність IoT-пристроїв та сенсорів від сторонніх виробників. 
2.	Стабільність роботи хмарних сервісів для зберігання та обробки даних. 
3.	Співпраця з агрономами та науковими установами для вдосконалення алгоритмів рекомендацій. 
4.	Розвиток технологій машинного навчання та аналізу даних для покращення точності прогнозів та рекомендацій.


1.3	Рамки та обмеження
1.3.1	Рамки первинного випуску


Перший випуск системи "SoilMonitoring" включатиме наступні ключові функції: 
1.	Реєстрація та автентифікація користувачів: 
-	Реєстрація нових користувачів 
-	Вхід в систему 
-	Базове розмежування прав доступу (користувачі та адміністратори) 
2.	Збір та передача даних: 
-	Інтеграція з IoT-пристроями для вимірювання вологості та температури ґрунту 
-	Відправка даних з IoT-пристроїв на сервер 
-	Збереження даних сенсорів у базі даних 
3.	Візуалізація даних: 
-	Відображення графіків вологості та температури ґрунту 
-	Базова фільтрація даних за датчиками та датами 
4.	Управління сенсорами: 
-	Додавання та видалення сенсорів для моніторингу 
-	Прив'язка сенсорів до конкретних ділянок 
5.	Базова рекомендаційна система: 
-	Генерація простих рекомендацій щодо поливу на основі даних вологості 
6.	Веб-інтерфейс: 
-	Адаптивний дизайн для ПК та мобільних пристроїв 
-	Підтримка української та англійської мов 
7.	Адміністративні функції: 
-	Базове управління користувачами (перегляд, блокування) 
-	Імпорт та експорт даних сенсорів


1.3.2	Рамки наступних випусків


У подальших версіях системи планується реалізувати: 
1.	Вдосконалена візуалізація: 
-	Інтерактивні карти ділянок з відображенням стану ґрунту 
-	Розширені можливості фільтрації та аналізу даних 
2.	Розширена рекомендаційна система: 
-	Аналіз даних про поживні речовини 
-	Генерація комплексних рекомендацій щодо поливу та внесення добрив 
-	Прогнозування врожайності на основі історичних даних 
3.	Управління культурами: 
-	Додавання інформації про культури та їх оптимальні умови вирощування 
-	Налаштування параметрів моніторингу під конкретні культури 
4.	Розширені адміністративні функції: 
-	Детальна аналітика використання системи 
5.	Мобільний додаток: 
-	Нативний додаток для iOS та Android з повним функціоналом веб-версії 
-	Підтримка push-сповіщень 
6.	Інтеграції: 
-	API для інтеграції з іншими сільськогосподарськими системами 
-	Підтримка додаткових IoT-пристроїв та сенсорів


1.3.3	Обмеження та винятки


1.	Система не передбачає прямого керування поливом чи внесенням добрив - вона надає рекомендації, але не контролює обладнання. 
2.	"SoilMonitoring" не є повноцінною системою управління фермерським господарством - вона фокусується на моніторингу ґрунту та не включає функції бухгалтерського обліку, управління персоналом тощо. 
3.	Початкова версія системи не передбачає інтеграції з метеорологічними сервісами для отримання прогнозів погоди. 
4.	Система не надає послуг з продажу або оренди IoT-пристроїв та сенсорів - користувачі повинні придбати їх самостійно. 
5.	"SoilMonitoring" не є заміною професійної агрономічної консультації - рекомендації системи слід розглядати як допоміжний інструмент. 
6.	Початкова версія не підтримує офлайн-режим роботи - для функціонування потрібне постійне інтернет-з'єднання. 
7.	Система не передбачає автоматичного оновлення прошивки IoT-пристроїв - це залишається відповідальністю користувача.


1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін 

Зацікавлена сторона	
Головна цінність	
Ставлення	
Головні інтереси	
Обмеження
Фермери малих та середніх господарств	Підвищення врожайності, економія ресурсів	Зацікавлене, але можуть бути обережними щодо нових технологій	Простота використання, економічна ефективність, надійність даних	Обмежений бюджет, можливий низький рівень технічної грамотності
Керівники великих агрохолдингів	Оптимізація процесів, підвищення ефективності виробництва	Прогресивне, готові інвестувати в інновації	Масштабованість рішення, інтеграція з існуючими системами, аналітичні можливості	Потреба в кастомізації, високі вимоги до безпеки даних
Агрономи	Доступ до точних даних, покращення якості рекомендацій	Зацікавлене, але можуть бути скептичними щодо автоматизованих рекомендацій	Детальність даних, гнучкість налаштувань, можливість внесення експертних корекцій	Необхідність інтеграції з традиційними методами роботи
Постачальники IoT-пристроїв	Розширення ринку збуту своєї продукції	Позитивне, зацікавлені у партнерстві	Легкість інтеграції їхніх пристроїв, технічна підтримка	Різноманітність протоколів та стандартів
Інвестори	Потенціал росту та масштабування бізнесу	Зацікавлене, але обережне	Бізнес-модель, потенціал виходу на міжнародні ринки, конкурентні переваги	Очікування швидкого повернення інвестицій




1.4.2	Пріоритети проєкту


Таблиця 1.2 – Пріоритети проєкту
Вибір	Драйвер
(мета)	Обмеження	Ступінь свободи
Розклад	Випуск версії 1.0 до початку посівного сезону (березень 2025)		Можливе зміщення дати випуску на 1-2 місяці за необхідності
Функціональність			80-90% ключових функцій повинні бути реалізовані у версії 1.0
Якість		Система повинна працювати стабільно 99.9% часу	90% тестів прийняття користувачем повинні пройти для релізу 1.0.
Персонал		Максимальний розмір команди - 10 розробників та 3 тестувальники	
Вартість		≈ 20 000 гривень	Допустиме відхилення на 20%


1.4.3	Робоче середовище


-	Користувачі системи географічно розподілені по всій території України, з потенціалом виходу на міжнародний ринок. 
-	Система повинна бути доступна 24/7, з особливо високою надійністю в період активних сільськогосподарських робіт. 
-	Дані генеруються IoT-пристроями на полях і передаються на центральний сервер для обробки та зберігання. 
-	Максимальний час відгуку системи при запиті даних не повинен перевищувати 3 секунди. 
-	Користувачі повинні мати доступ до системи як з офісних комп'ютерів, так і з мобільних пристроїв у польових умовах. 
-	Система повинна забезпечувати шифрування даних при передачі та зберіганні для захисту конфіденційної інформації користувачів. 
-	Необхідна підтримка роботи в умовах нестабільного інтернет-з'єднання, з можливістю синхронізації даних при відновленні зв'язку. 
-	Система повинна відповідати вимогам GDPR та українського законодавства щодо захисту персональних даних. 
-	Для розробки системи використовуватимуться:
1.	Front/back-end: html, css, reactjs[1], nodejs, expressjs, а доступ до даних буде через базу даних MongoDB.
2.	IoT: C++, Arduino framework, ESP32, DHT22.
 
2	ОПИС АРХІТЕКТУРИ СИСТЕМИ
2.1	Опис архітектури серверної частини


Серверна частина нашої системи моніторингу землі побудована на основі Node.js з використанням фреймворку Express.js[1]. Архітектура серверної частини слідує принципам RESTful API[2] та модульного дизайну. Наведемо детальний опис компонентів серверної частини:
1.	Основні компоненти: 
a)	Сервер Express.js (app.js): 
–	Налаштування middleware (cors, bodyParser)
–	Підключення до MongoDB 
–	Налаштування маршрутів API 
b)	Маршрутизація (routes): 
–	authRoutes.js - маршрути для автентифікації 
–	cropRoutes.js - маршрути для роботи з культурами r
–	recommendationRoutes.js - маршрути для отримання рекомендацій 
–	sensorRoutes.js - маршрути для роботи з даними сенсорів 
–	userRoutes.js – маршрути для управління користувачами 
c)	Контролери (controllers): 
–	authController.js - логіка автентифікації 
–	cropController.js - управління даними про культури r
–	recommendationController.js - генерація рекомендацій 
–	sensorController.js - обробка даних сенсорів 
–	userController.js - управління користувачами 
d)	Моделі даних (models): 
–	User.js - модель користувача 
–	Crop.js - модель сільськогосподарської культури 
–	SensorData.js - модель даних сенсорів 
e)	Сервіси (services): 
–	analysisService.js - аналіз даних та генерація рекомендацій 
f)	Middleware: 
–	authMiddleware.js - перевірка автентифікації 
–	adminMiddleware.js - перевірка прав адміністратора
2.	Взаємодія компонентів: 
a)	Запити клієнта надходять до сервера Express.js. 
b)	Маршрутизатор направляє запити до відповідних контролерів. 
c)	Контролери обробляють запити, взаємодіючи з моделями та сервісами. 
d)	Моделі забезпечують взаємодію з базою даних MongoDB. 
e)	Сервіси виконують складну бізнес-логіку, наприклад, аналіз даних сенсорів. 
f)	Результати обробки повертаються клієнту у форматі JSON.
3.	Особливості реалізації: 
a)	Використання асинхронних функцій (async/await) для ефективної обробки запитів. 
b)	Застосування middleware для автентифікації та авторизації. 
c)	Модульна структура, що дозволяє легко розширювати функціональність. 
d)	Використання MongoDB для зберігання даних, що забезпечує гнучкість схеми та масштабованість.
4.	Безпека: 
a)	Використання bcrypt для хешування паролів користувачів. 
b)	Застосування JSON Web Tokens (JWT)[3] для автентифікації. 
c)	Middleware для перевірки прав доступу до різних ендпоінтів API. 
Така архітектура забезпечує розділення відповідальності між компонентами, що полегшує розробку, тестування та подальшу підтримку системи. Також, модульний підхід дозволяє легко додавати нові функції та масштабувати систему в міру необхідності.

 
Рисунок 2.1 – Діаграма розгортання

На рисунку 2.1 зображено діаграму розгортання для системи моніторингу землі. Ця діаграма показує фізичну архітектуру системи та взаємозв'язки між її компонентами, показує як ці компоненти взаємодіють між собою: клієнти спілкуються з сервером через HTTP/HTTPS, сервер звертається до бази даних, а датчики надсилають дані на сервер. Це дозволяє зрозуміти, як система фізично розгорнута та як відбувається обмін даними між її частинами.

 
Рисунок 2.2 – Діаграма прецендентів

Тепер наведемо детальний опис ролей та їх взаємодією з системою(див. рис. 2.2):
1.	Користувач: 
–	Реєстрація: створення нового облікового запису в системі. 
–	Вхід в систему: автентифікація користувача для доступу до функцій системи. 
–	Перегляд даних сенсорів: доступ до інформації про вологість, температуру та вміст поживних речовин у ґрунті. 
–	Отримання рекомендацій: отримання порад щодо догляду за культурами на основі даних сенсорів. 
–	Вибір сенсорів для моніторингу: налаштування списку сенсорів, дані яких користувач хоче відстежувати. 
–	Перегляд інформації про культури: доступ до довідкової інформації про різні сільськогосподарські культури. 
2.	Адміністратор (додатково до функцій користувача): 
–	Управління користувачами: перегляд списку користувачів та їх даних. 
–	Блокування/розблокування користувачів: контроль доступу користувачів до системи. 
–	Видалення користувачів: видалення облікових записів з системи. 
–	Додавання нових культур: внесення інформації про нові сільськогосподарські культури. 
–	Імпорт/експорт даних сенсорів: можливість масового завантаження або вивантаження даних сенсорів. 


2.2	Опис архітектури IoT частини


Пристрій IoT[4] для моніторингу ґрунту складається з наступних компонентів(див. рис. 2.3, с. 25): 
1.	Мікроконтролер ESP32: 
–	Основний обчислювальний модуль 
–	Забезпечує підключення до Wi-Fi для передачі даних 
–	Керує роботою сенсорів та обробляє отримані дані 
2.	Датчик DHT22: 
–	Вимірює температуру та вологість ґрунту 
–	Підключений до цифрового піну D21 ESP32 
3.	Потенціометр: 
–	Імітує аналоговий датчик поживних речовин 
–	Підключений до аналогового піну D35 ESP32 
4.	Модуль Wi-Fi (вбудований в ESP32): 
–	Забезпечує бездротове підключення до мережі 
–	Дозволяє відправляти дані на сервер

 
Рисунок 2.3 – Будова IoT пристрою

Принцип роботи: 
1.	ESP32 ініціалізує датчики та підключається до Wi-Fi мережі. 
2.	Кожні 30 секунд ESP32 зчитує дані з датчиків: 
–	Температура та вологість ґрунту з DHT22 
–	Рівень поживних речовин з потенціометра 
3.	Отримані дані форматуються у JSON-структуру. 
4.	За допомогою HTTP POST-запиту дані відправляються на сервер. 
5.	ESP32 очікує наступного циклу вимірювань.

 
Рисунок 2.4 – Діаграма прецедентів

Опишемо взаємодію користувачів з IoT-пристроєм за допомогою діаграми прецедентів(див. рис. 2.4) та діаграми взаємодії(див. рис. 2.5, с. 27):
1.	Підключення до Wi-Fi: 
–	Встановлення з'єднання з заданою Wi-Fi мережею 
–	Очікування успішного підключення 
2.	Відправка даних на сервер: 
–	Формування HTTP POST-запиту 
–	Відправка даних на вказаний URL серверу 
3.	Відображення результату запиту: 
–	Отримання статусу запиту 
4.	Очікування: 
–	Пауза на 30 секунд перед наступним циклом вимірювань

 
Рисунок 2.5 – Діаграма взаємодії

Відобразимо послідовність дій, які виконує IoT пристрій під час свого функціонування. Діаграма діяльності(див. рис. 2.6, с. 28) показує процес підключення, збору даних, їх обробки та відправки, а також включає обробку можливих помилок на кожному етапі. В діаграмі також представлена циклічна природа роботи пристрою.

 
Рисунок 2.6 – Діаграма діяльності

Тепер у діаграмі станів(див. рис. 2.7, с. 29) відобразимо різні стани, в яких може перебувати IoT пристрій під час своєї роботи, а також переходи між цими станами. Дана діаграма станів допомагає зрозуміти логіку роботи пристрою та його поведінку в різних ситуаціях, включаючи обробку помилок та енергоефективну роботу.

 
Рисунок 2.7 – Діаграма станів


2.3	Опис архітектури клієнтської частини


Клієнтська частина системи моніторингу землі для сільськогосподарських потреб розроблена з використанням React[5] - популярної бібліотеки JavaScript для створення користувацьких інтерфейсів. Архітектура клієнтської частини базується на компонентному підході, що забезпечує модульність, повторне використання коду та легкість в обслуговуванні. 
Основні компоненти архітектури(див. рис. 2.8, с. 31):
1.	App.js: Це кореневий компонент, який відповідає за загальну структуру додатку, маршрутизацію та управління станом авторизації. 
2.	Dashboard.js: Компонент панелі управління, який відображає дані з сенсорів у вигляді графіків. 
3.	AdminPanel.js: Компонент панелі адміністратора для управління користувачами та даними. 
4.	Recommendations.js: Компонент, який відображає рекомендації на основі даних сенсорів. 
5.	Login.js та Register.js: Компоненти для авторизації та реєстрації користувачів. 
6.	UserManagement.js: Компонент для управління користувачами (в рамках AdminPanel). 
7.	DataManagement.js: Компонент для імпорту та експорту даних (в рамках AdminPanel). 
Архітектурні особливості: 
1.	Компонентний підхід: Кожен функціональний елемент системи реалізований як окремий React-компонент, що забезпечує модульність та повторне використання коду. 
2.	Маршрутизація: Використовується React Router для навігації між різними сторінками додатку. 
3.	Управління станом: Локальний стан компонентів використовується для зберігання та управління даними на рівні компонентів. 
4.	Інтернаціоналізація: Реалізована з використанням бібліотеки i18next для підтримки багатомовності. 
5.	HTTP-запити: Axios використовується для здійснення HTTP-запитів до серверної частини. 
6.	Візуалізація даних: Бібліотека Recharts застосовується для створення графіків та візуалізації даних сенсорів. 
7.	UI компоненти: Material-UI (MUI) використовується для створення сучасного та респонсивного інтерфейсу користувача.

 
Рисунок 2.8 – Діаграма компонент

Опишемо взаємодію користувачів з клієнтською частиною за допомогою діаграми прецедентів(див. рис. 2.9, с. 32) та діаграми взаємодії(див. рис. 2.10, с. 32). У діаграмі прецедентів відображується основна функціональність системи та взаємодія користувачів з нею. Діаграма взаємодії ж показує основні потоки взаємодії між користувачем, компонентами клієнтської частини та API сервера. Вона демонструє послідовність дій при авторизації, перегляді даних сенсорів, отриманні рекомендацій та керуванні користувачами в панелі адміністратора.

 
Рисунок 2.9 – Діаграма прецедентів

 
Рисунок 2.10 – Діаграма взаємодії
Тепер відобразимо основні стани(див. рис. 2.11), в яких може перебувати клієнтська частина системи, та можливі переходи між цими станами: 
1.	Система починає роботу в неавторизованому стані. 
2.	Після успішної авторизації користувач потрапляє на головну панель. 
3.	З головної панелі користувач може перейти до різних функціональних станів: перегляд даних сенсорів, управління рекомендаціями, адміністративна панель (для адміністраторів). 
4.	З будь-якого стану можна повернутися на головну панель.
5.	Вихід з системи повертає користувача до неавторизованого стану.

 
Рисунок 2.11 – Діаграма станів 
3	ПРОЄКТУВАННЯ БАЗИ ДАНИХ


Для реалізації цієї програмної системи моніторингу землі була обрана база даних MongoDB[6] через свою гнучкість, масштабованість, швидкодію та відмінну інтеграцію з Node.js через Mongoose, що дозволяє ефективно зберігати та обробляти різноманітні дані від сенсорів, забезпечуючи при цьому високу продуктивність та масштабованість. Усі сутності, атрибути і зв’язки організовані у вигляді ER-діаграми(див. рис.3.1).

 
Рисунок 3.1 - ER-діаграма програмної системи моніторингу землі для сільськогосподарських потреб

Таким чином, структуру бази даних можна описати наступним чином:
1.	Таблиця User (Користувач): 
–	id: унікальний ідентифікатор користувача (первинний ключ) 
–	username: ім'я користувача 
–	fullName: повне ім'я користувача 
–	email: електронна адреса користувача 
–	password: пароль користувача (зберігається у зашифрованому вигляді) 
–	role: роль користувача (користувач або адміністратор) 
–	banned: прапорець, що вказує, чи заблокований користувач 
2.	Таблиця Sensor (Датчик): 
–	id: унікальний ідентифікатор датчика (первинний ключ) 
–	userId: зовнішній ключ, що посилається на користувача, якому належить датчик 
–	cropName: назва культури, для якої використовується датчик 
3.	Таблиця SensorData (Дані датчика): 
–	id: унікальний ідентифікатор запису даних (первинний ключ) 
–	sensorId: зовнішній ключ, що посилається на датчик 
–	type: тип даних (вологість ґрунту, температура ґрунту або поживні речовини) 
–	value: значення виміру 
–	timestamp: часова мітка виміру 
4.	Таблиця Crop (Культура): 
–	id: унікальний ідентифікатор культури (первинний ключ) 
–	name: назва культури 
–	optimalSoilMoisture: оптимальна вологість ґрунту для цієї культури 
–	optimalSoilTemperature: оптимальна температура ґрунту для цієї культури 
–	requiredNutrients: необхідні поживні речовини для цієї культури
Маємо наступні зв’язки між таблицями:
-	Користувач пов’язаний з датчиком зв’язком «один-до-багатьох», оскільки один користувач може мати багато датчиків.
-	Датчик пов’язаний з даними датчика зв’язком «один-до-багатьох», оскільки один датчик може мати багато записів даних.
-	Культура пов’язана з датчиком зв’язком «один-до-багатьох», оскільки багато датчиків можуть бути пов'язані з однією культурою.
 
4	ОПИС ПРОГРАМИ
4.1	 Виклик і завантаження


Для виклику та завантаження "Програмної системи моніторингу землі для сільськогосподарських потреб" необхідно виконати ряд кроків. Спочатку потрібно переконатися, що на комп'ютері встановлено Node.js та npm. Якщо ці компоненти відсутні, їх слід завантажити та встановити з офіційного сайту Node.js. 
Наступним кроком є клонування репозиторію проекту з GitHub[7] або завантаження архіву з кодом. Після отримання файлів проекту, потрібно відкрити термінал і перейти до кореневої папки проекту. У цій папці необхідно виконати команду "npm install" для встановлення всіх залежностей, вказаних у файлі package.json. 
Для налаштування бази даних MongoDB потрібно встановити її на локальному комп'ютері або використовувати хмарний сервіс, наприклад, MongoDB Atlas. Після встановлення бази даних, необхідно створити файл .env у кореневій папці проекту і вказати в ньому URL-адресу підключення до MongoDB та інші необхідні змінні середовища, такі як JWT_SECRET для шифрування токенів. 
Щоб запустити серверну частину програми, слід виконати команду "npm start" у терміналі, знаходячись у папці сервера. Сервер запуститься на порту, вказаному в налаштуваннях. 
Для запуску клієнтської частини потрібно відкрити новий термінал, перейти до папки клієнта і виконати команду "npm start". Це запустить розробницький сервер React, який зазвичай працює на порту 3000. Якщо цей порт вже зайнятий (наприклад, серверною частиною), React запропонує використати інший порт. 
Для роботи з IoT-частиною системи необхідно мати ESP32 або сумісний пристрій. Код для ESP32 можна завантажити за допомогою Arduino IDE або PlatformIO. Перед завантаженням коду слід переконатися, що всі необхідні бібліотеки встановлені, а також налаштувати параметри WiFi та адресу сервера в коді. 
Після успішного запуску всіх компонентів системи, веб-інтерфейс буде доступний через веб-браузер за адресою http://localhost:3000 (або на іншому порту, якщо він був змінений). Для входу в систему потрібно створити обліковий запис або використовувати тестові дані, якщо вони передбачені в проекті.


4.2	 Призначення і логічна структура


Дана програмна система[8] створена для поліпшення процесу моніторингу та аналізу стану ґрунту для сільськогосподарських потреб. Система дозволяє фермерам та агрономам отримувати актуальні дані про стан ґрунту, аналізувати їх та отримувати рекомендації щодо догляду за посівами. 
Система складається з трьох основних компонентів, а саме: IoT-пристрої (датчики), серверна частина  та веб-інтерфейс 
IoT-пристрої збирають дані про вологість ґрунту, температуру ґрунту та вміст поживних речовин (азот, фосфор, калій). Ці дані передаються на сервер через Wi-Fi з'єднання. 
Серверна частина обробляє отримані дані, зберігає їх у базі даних та виконує аналіз для формування рекомендацій. Сервер також забезпечує API для взаємодії з веб-інтерфейсом. 
Веб-інтерфейс надає користувачам можливість переглядати дані з датчиків, отримувати рекомендації та керувати системою. Він складається з наступних основних сторінок: 
-	Панель керування - відображає актуальні дані з датчиків у вигляді графіків (див. рис. 4.4, с. 41). 
-	Рекомендації - показує рекомендації щодо догляду за посівами на основі аналізу даних (див. рис. 4.6, с. 42). 
-	Панель адміністратора - для керування користувачами та імпорту/експорту даних (доступна тільки для адміністраторів) (див. рис. 4.8, с. 43). 
Система надає користувачам такі основні функції: 
-	Перегляд актуальних даних про стан ґрунту у вигляді графіків 
-	Отримання рекомендацій щодо поливу та внесення добрив 
-	Додавання  датчиків у зв’язці з необхідною культурою для яких ми плануємо переглядати рекомендації 
-	Експорт та імпорт даних 
-	Керування користувачами (для адміністраторів) 


4.3	 Опис програмної реалізації


Після запуску програми відкривається сторінка авторизації (див. рис. 4.1), де користувач може ввести свої облікові дані для входу в систему. Ця сторінка містить поля для введення імені користувача та пароля, а також кнопку "Увійти". Якщо користувач ще не має облікового запису, він може перейти на сторінку реєстрації, натиснувши на відповідне посилання.

 
Рисунок 4.1 - Сторінка авторизації
Сторінка реєстрації (див. рис. 4.2) дозволяє новим користувачам створити обліковий запис. Вона містить поля для введення імені користувача, повного імені, електронної пошти та пароля. Після заповнення всіх необхідних полів користувач може натиснути кнопку "Зареєструватися" для створення нового облікового запису.

 
Рисунок 4.2 - Сторінка реєстрації

Після входу в систему користувач потрапляє на головну сторінку веб-інтерфейсу (див. рис. 4.3), яка складається з декількох основних розділів: "Панель керування", "Рекомендації", "Адміністративна панель" та "Налаштування". 

 
Рисунок 4.3 - Головна сторінка веб-інтерфейсу 

На сторінці "Панель керування" (див. рис. 4.4, с. 41) користувач може переглядати дані з датчиків у режимі реального часу. Ця сторінка містить графіки, що відображають показники вологості ґрунту, температури ґрунту, рівня азоту, фосфору та калію. Користувач може вибрати конкретний датчик або переглядати дані з усіх датчиків одночасно. Також є можливість вибору дати для перегляду історичних даних. 

 
Рисунок 4.4 - Сторінка "Панель керування"

Важливою особливістю системи є можливість перемикання мови інтерфейсу. На рисунку 4.5 показано ту ж саму сторінку "Панель керування", але з українським інтерфейсом. 

 
Рисунок 4.5 - Сторінка "Панель керування" українською мовою

Перейшовши на сторінку "Рекомендації" (див. рис. 4.6, с. 42), користувач може отримати автоматично згенеровані рекомендації щодо догляду за посівами. Ця сторінка містить список вибраних датчиків та культур, а також відповідні рекомендації щодо поливу, внесення добрив тощо. 

 
Рисунок 4.6 - Сторінка "Рекомендації"

На цій же сторінці користувач може додавати нові датчики до списку моніторингу, вибираючи датчик та відповідну культуру зі спадного меню (див. рис. 4.7). 

 
Рисунок 4.7 - Додавання нового датчика на сторінці "Рекомендації"
Адміністратори системи мають доступ до "Панелі адміністратора" (див. рис. 4.8), де можна керувати користувачами системи. Ця сторінка дозволяє додавати нових користувачів, редагувати існуючі облікові записи, блокувати або видаляти користувачів. 

 
Рисунок 4.8 - Сторінка "Панель адміністратора"

Система також надає можливість експорту та імпорту даних. На сторінці "Панелі адміністратора" у графі "Управління даними" (див. рис. 4.9) адміністратори можуть експортувати всі дані системи у форматі JSON для резервного копіювання або аналізу, а також імпортувати дані з файлу. 

 
Рисунок 4.9 - Графа "Управління даними" розташована у "Панелі адміністратора"

Таким чином, веб-інтерфейс "Програмної системи моніторингу землі для сільськогосподарських потреб" надає користувачам зручний доступ до всіх функцій системи, включаючи перегляд даних з датчиків, отримання рекомендацій, керування користувачами та налаштування системи.
 
ВИСНОВКИ


У ході роботи було розроблено програмну систему моніторингу землі для сільськогосподарських потреб, яка включає в себе IoT-пристрої для збору даних, серверну частину для їх обробки та зберігання, а також веб-інтерфейс для візуалізації, управління та отримання сповіщень та рекомендацій. 
Розроблена система дає можливість збирати та зберігати дані про вологість ґрунту, температуру ґрунту та рівень поживних речовин. Програма підтримує такі функції, як: реєстрація та автентифікація користувачів, управління сенсорами, візуалізація даних у вигляді графіків, фільтрація даних за різними параметрами, генерація рекомендацій щодо поливу та внесення добрив. Крім цього, система має багатомовний інтерфейс з підтримкою української та англійської мов та адаптивний дизайн для різних пристроїв. 
Таким чином, хоча система і має певні перспективи для подальшого вдосконалення та розширення функціоналу, отриманий продукт виконує всі необхідні функції та є досить зручним, зрозумілим та ефективним для користувачів. Програмна система значно полегшує роботу аграріїв, надаючи їм інструменти для ефективного моніторингу стану ґрунту, своєчасного реагування на зміни умов та прийняття обґрунтованих рішень щодо догляду за культурами. 
Розроблена система моніторингу землі має потенціал для підвищення ефективності сільськогосподарського виробництва, оптимізації використання ресурсів та збільшення врожайності. Вона відповідає сучасним вимогам до автоматизації процесів у сільському господарстві та може стати важливим інструментом для впровадження точного землеробства.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Express documentation URL: https://expressjs.com/en/guide/routing.html (дата звернення 01.05.2024).
2.	API RESTful documentation. URL: https://restfulapi.net (дата звернення 25.04.2024).
3.	JSON Web Tokens documentation. URL: https://jwt.io/introduction (дата звернення 19.05.2024).
4.	Cuno Pfister. Getting Started with the Internet of Things: Connecting Sensors and Microcontrollers to the Cloud, 1st Edition. : Make Community, LLC, 2011 — 191 p.
5.	React documentation. URL: https://reactjs.org (дата звернення: 29.04.2024).
6.	Створення бази даних MongoDB. URL: https://www.mongodb.com/resources/products/fundamentals/create-database  (дата звернення 18.04.2024).
7.	Посилання на репозиторій GitHub: https://github.com/NureShevchenkoIvan/apzkr-pzpi-21-8-shevchenko-ivan
8.	Посилання на функціональне тестування програмної системи: https://youtu.be/wlr6MSSJ_Bc
 
ДОДАТОК А
Код серверної частини


Код файлу app.js:

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const SensorData = require('./models/SensorData');

dotenv.config();

const app = express();

// Middleware
app.use(cors({
  origin: '*'
}));
app.use(bodyParser.json());

app.get('/api/sensors/data', async (req, res) => {
  try {
    let query = {};
    
    // Додаємо фільтри, якщо вони є в запиті
    if (req.query.sensorId) {
      query.sensorId = req.query.sensorId;
    }
    if (req.query.type) {
      query.type = req.query.type;
    }
    
    // Додаємо фільтр за датою, якщо вказані параметри
    if (req.query.startDate && req.query.endDate) {
      query.timestamp = {
        $gte: new Date(req.query.startDate),
        $lte: new Date(req.query.endDate)
      };
    }

    const data = await SensorData.find(query).sort({ timestamp: -1 }).limit(100);
    
    console.log('Sending sensor data:', data);  // Для відлагодження
    res.json(data);
  } catch (error) {
    console.error('Error fetching sensor data:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

const PORT = process.env.PORT || 3000;

// Connect to MongoDB
mongoose.connect(process.env.MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('Failed to connect to MongoDB:', err));

// Routes
app.use('/api/sensors', require('./routes/sensorRoutes'));
app.use('/api/crops', require('./routes/cropRoutes'));
app.use('/api/recommendations', require('./routes/recommendationRoutes'));
app.use('/api/users', require('./routes/userRoutes'));

const authRoutes = require('./routes/authRoutes');

app.use('/api/auth', authRoutes);

// Start server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

Код файлу authController.js:

const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.register = async (req, res) => {
  try {
    const { username, fullName, email, password } = req.body;
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ username, fullName, email, password: hashedPassword });
    await newUser.save();
    res.status(201).json({ message: 'User registered successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { username, password } = req.body;
    const user = await User.findOne({ username });
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }
    if (user.banned) {
      return res.status(403).json({ message: 'User is banned' });
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ userId: user._id, role: user.role }, process.env.JWT_SECRET);
    res.json({ token, role: user.role });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

Код файлу cropController.js:

const Crop = require('../models/Crop');

exports.createCrop = async (req, res) => {
  try {
    const newCrop = new Crop(req.body);
    await newCrop.save();
    res.status(201).json(newCrop);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

exports.getAllCrops = async (req, res) => {
  try {
    const crops = await Crop.find();
    res.json(crops);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

Код файлу recommendationController.js:

const User = require('../models/User');
const analysisService = require('../services/analysisService');

exports.addSelectedSensor = async (req, res) => {
  try {
    const { userId } = req.user;
    const { sensorId, cropName } = req.body;
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    user.selectedSensors.push({ sensorId, cropName });
    await user.save();
    res.status(200).json({ message: 'Sensor added successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.removeSelectedSensor = async (req, res) => {
  try {
    const { userId } = req.user;
    const { sensorId, cropName } = req.query;
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    user.selectedSensors = user.selectedSensors.filter(
      sensor => !(sensor.sensorId === sensorId && sensor.cropName === cropName)
    );
    await user.save();
    res.status(200).json({ message: 'Sensor removed successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.getSelectedSensors = async (req, res) => {
  try {
    const { userId } = req.user;
    const user = await User.findById(userId).select('selectedSensors');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(user.selectedSensors);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.getRecommendations = async (req, res) => {
    try {
      const { userId } = req.user;
      const recommendations = await analysisService.analyzeSoilConditions(userId);
      res.json(recommendations);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  };

Код файлу sensorController.js:

const SensorData = require('../models/SensorData');
const analysisService = require('../services/analysisService');

exports.receiveSensorData = async (req, res) => {
  try {
    const { sensorId, type, value } = req.body;
    const newSensorData = new SensorData({ sensorId, type, value });
    await newSensorData.save();
    res.status(201).json({ message: 'Sensor data saved successfully' });
  } catch (error) {
    console.error("Error in receiveSensorData:", error);
    res.status(500).json({ error: error.message });
  }
};

exports.getSensorData = async (req, res) => {
  try {
    const { sensorId, type, startDate, endDate } = req.query;
    const query = { sensorId, type };
    if (startDate && endDate) {
      query.timestamp = { $gte: new Date(startDate), $lte: new Date(endDate) };
    }
    const data = await SensorData.find(query).sort({ timestamp: 1 });
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.importSensorData = async (req, res) => {
  try {
    const sensorData = req.body;

    await SensorData.insertMany(sensorData);

    res.status(200).json({ message: 'Sensor data imported successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.exportSensorData = async (req, res) => {
  try {
    const sensorData = await SensorData.find();
    res.status(200).json(sensorData);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

exports.getRecommendations = async (req, res) => {
  try {
    const { sensorId, cropName } = req.query;
    const recommendations = await analysisService.analyzeSoilConditions(req.user.userId);
    res.json(recommendations);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

Код файлу userController.js:

const User = require('../models/User');

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password');
    res.status(200).json(users);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const { userId } = req.params;
    const { username, email } = req.body;
    const user = await User.findByIdAndUpdate(
      userId,
      { username, email },
      { new: true }
    ).select('-password');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(user);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.banUser = async (req, res) => {
  try {
    const { userId } = req.params;
    const user = await User.findByIdAndUpdate(
      userId,
      { banned: true },
      { new: true }
    ).select('-password');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(user);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.unbanUser = async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await User.findByIdAndUpdate(
        userId,
        { banned: false },
        { new: true }
      ).select('-password');
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      res.status(200).json(user);
    } catch (error) {
      res.status(500).json({ message: error.message });
    }
  };

exports.deleteUser = async (req, res) => {
  try {
    const { userId } = req.params;
    const user = await User.findByIdAndDelete(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json({ message: 'User deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

Код файлу adminMiddleware.js:

module.exports = (req, res, next) => {
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }
    next();
  };

Код файлу authMiddleware.js:

const jwt = require('jsonwebtoken');
const User = require('../models/User');

module.exports = async (req, res, next) => {
  try {
    const token = req.header('Authorization').replace('Bearer ', '');
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findOne({ _id: decoded.userId });

    if (!user) {
      throw new Error('User not found');
    }

    req.user = { userId: user._id, role: user.role };
    next();
  } catch (error) {
    res.status(401).json({ error: 'Authentication required' });
  }
};

Код файлу Crop.js:

const mongoose = require('mongoose');

const cropSchema = new mongoose.Schema({
  name: { type: String, required: true, unique: true },
  optimalSoilMoisture: { type: Number, required: true }, // %
  optimalSoilTemperature: { type: Number, required: true }, // °C
  requiredNutrients: {
    nitrogen: { type: Number, required: true }, // ppm
    phosphorus: { type: Number, required: true }, // ppm
    potassium: { type: Number, required: true } // ppm
  }
});

module.exports = mongoose.model('Crop', cropSchema);

Код файлу SensorData.js:

const mongoose = require('mongoose');

const sensorDataSchema = new mongoose.Schema({
  sensorId: { type: String, required: true },
  type: { type: String, enum: ['soil_moisture', 'soil_temperature', 'nutrients'], required: true },
  value: {
    type: mongoose.Schema.Types.Mixed,
    required: true,
    validate: {
      validator: function(v) {
        if (this.type === 'nutrients') {
          return typeof v === 'object' && v !== null && 'nitrogen' in v && 'phosphorus' in v && 'potassium' in v;
        }
        return typeof v === 'number';
      },
      message: props => `${JSON.stringify(props.value)} is not a valid value for sensor type ${props.type}!`
    }
  },
  timestamp: { type: Date, default: Date.now }
});

module.exports = mongoose.model('SensorData', sensorDataSchema);

Код файлу User.js:

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  fullName: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  banned: { type: Boolean, default: false },
  selectedSensors: [
    {
      sensorId: { type: String, required: true },
      cropName: { type: String, required: true }
    }
  ]
});

module.exports = mongoose.model('User', userSchema);

Код файлу authRoutes.js:

const express = require('express');
const authController = require('../controllers/authController');

const router = express.Router();

router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;

Код файлу cropRoutes.js:

const express = require('express');
const cropController = require('../controllers/cropController');

const router = express.Router();

router.post('/', cropController.createCrop);
router.get('/', cropController.getAllCrops);

module.exports = router;

Код файлу recommendationRoutes.js:

const express = require('express');
const recommendationController = require('../controllers/recommendationController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

router.get('/', authMiddleware, recommendationController.getRecommendations);
router.post('/selected', authMiddleware, recommendationController.addSelectedSensor);
router.delete('/selected', authMiddleware, recommendationController.removeSelectedSensor);
router.get('/selected', authMiddleware, recommendationController.getSelectedSensors);

module.exports = router;

Код файлу sensorRoutes.js:

const express = require('express');
const sensorController = require('../controllers/sensorController');
const authMiddleware = require('../middlewares/authMiddleware');

const router = express.Router();

router.post('/data', sensorController.receiveSensorData);
router.get('/data', sensorController.getSensorData);
router.post('/data/import', authMiddleware, sensorController.importSensorData);
router.get('/data/export', authMiddleware, sensorController.exportSensorData);
router.get('/recommendations', authMiddleware, sensorController.getRecommendations);

module.exports = router;

Код файлу userRoutes.js:

const express = require('express');
const userController = require('../controllers/userController');
const authMiddleware = require('../middlewares/authMiddleware');
const adminMiddleware = require('../middlewares/adminMiddleware');

const router = express.Router();

router.get('/', authMiddleware, adminMiddleware, userController.getAllUsers);
router.put('/:userId', authMiddleware, adminMiddleware, userController.updateUser);
router.put('/:userId/ban', authMiddleware, adminMiddleware, userController.banUser);
router.put('/:userId/unban', authMiddleware, adminMiddleware, userController.unbanUser);
router.delete('/:userId', authMiddleware, adminMiddleware, userController.deleteUser);

module.exports = router;

Код файлу analysisService.js:

const SensorData = require('../models/SensorData');
const Crop = require('../models/Crop');
const User = require('../models/User');
const moment = require('moment-timezone');

exports.analyzeSoilConditions = async (userId) => {
  const user = await User.findById(userId);
  const { selectedSensors, timezone } = user;
  const recommendations = [];

  for (const { sensorId, cropName } of selectedSensors) {
    const crop = await Crop.findOne({ name: cropName });
    if (!crop) continue;

    const [moistureData, temperatureData, nutrientsData] = await Promise.all([
      SensorData.findOne({ sensorId, type: 'soil_moisture' }).sort({ timestamp: -1 }),
      SensorData.findOne({ sensorId, type: 'soil_temperature' }).sort({ timestamp: -1 }),
      SensorData.findOne({ sensorId, type: 'nutrients' }).sort({ timestamp: -1 })
    ]);

    if (!moistureData || !temperatureData || !nutrientsData) {
      continue;
    }

    const localTimestamp = moment.tz(moistureData.timestamp, timezone).format();

    // Moisture analysis
    if (moistureData.value < crop.optimalSoilMoisture - 10) {
      recommendations.push({
        sensorId,
        cropName,
        data: { moisture: moistureData.value },
        timestamp: localTimestamp,
        recommendation: `Water needed: soil moisture is ${moistureData.value}%, optimal for ${cropName} is ${crop.optimalSoilMoisture}%`
      });
    }

    // Temperature analysis
    if (Math.abs(temperatureData.value - crop.optimalSoilTemperature) > 5) {
      recommendations.push({
        sensorId,
        cropName,
        data: { temperature: temperatureData.value },
        timestamp: localTimestamp,
        recommendation: `Warning: soil temperature is ${temperatureData.value}°C, optimal for ${cropName} is ${crop.optimalSoilTemperature}°C`
      });
    }

    // Nutrients analysis
    const { nitrogen, phosphorus, potassium } = nutrientsData.value;
    if (nitrogen < crop.requiredNutrients.nitrogen) {
      recommendations.push({
        sensorId,
        cropName,
        data: { nutrients: { nitrogen } },
        timestamp: localTimestamp,
        recommendation: `Add nitrogen fertilizer: current ${nitrogen} ppm, required ${crop.requiredNutrients.nitrogen} ppm`
      });
    }

    if (phosphorus < crop.requiredNutrients.phosphorus) {
      recommendations.push({
        sensorId,
        cropName,
        data: { nutrients: { phosphorus } },
        timestamp: localTimestamp,
        recommendation: `Add phosphorus fertilizer: current ${phosphorus} ppm, required ${crop.requiredNutrients.phosphorus} ppm`
      });
    }

    if (potassium < crop.requiredNutrients.potassium) {
      recommendations.push({
        sensorId,
        cropName,
        data: { nutrients: { potassium } },
        timestamp: localTimestamp,
        recommendation: `Add potassium fertilizer: current ${potassium} ppm, required ${crop.requiredNutrients.potassium} ppm`
      });
    }
  }

  return recommendations;
}; 
ДОДАТОК Б
Код IoT частини


Код файлу main.cpp:

#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <DHT.h>

#define DHTPIN 21
#define DHTTYPE DHT22
#define NUTRIENT_PIN 35

DHT dht(DHTPIN, DHTTYPE);

const char* ssid = "Wokwi-GUEST";
const char* password = "";
const char* serverUrl = "http://192.168.31.85:3000/api/sensors/data";

void setup() {
  Serial.begin(115200);
  dht.begin();
  
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void sendSensorData(const char* sensorType, float value) {
  StaticJsonDocument<200> doc;
  doc["sensorId"] = "esp32_001";
  doc["type"] = sensorType;
  doc["value"] = value;

  String postData;
  serializeJson(doc, postData);

  HTTPClient http;
  http.begin(serverUrl);
  http.addHeader("Content-Type", "application/json");

  int httpResponseCode = http.POST(postData);

  if (httpResponseCode >= 200 && httpResponseCode < 300) {
    Serial.printf("%s data sent successfully. Value: %.2f\n", sensorType, value);
  } else {
    Serial.printf("Error sending %s data: %d\n", sensorType, httpResponseCode);
  }

  http.end();
}

void sendNutrientData() {
  int nutrientValue = analogRead(NUTRIENT_PIN);
  
  // Масштабуємо значення до різних діапазонів для кожного елемента
  int nitrogen = map(nutrientValue, 0, 4095, 0, 400);
  int phosphorus = map(nutrientValue, 0, 4095, 0, 300);  // Менший діапазон для фосфору
  int potassium = map(nutrientValue, 0, 4095, 100, 400);  // Зміщений діапазон для калію

  // Додаємо невелику випадкову варіацію для кожного елемента
  nitrogen += random(-20, 21);  // +/- 20
  phosphorus += random(-15, 16);  // +/- 15
  potassium += random(-25, 26);  // +/- 25

  // Обмежуємо значення в межах допустимого діапазону
  nitrogen = constrain(nitrogen, 0, 400);
  phosphorus = constrain(phosphorus, 0, 400);
  potassium = constrain(potassium, 0, 400);

  StaticJsonDocument<200> doc;
  doc["sensorId"] = "esp32_001";
  doc["type"] = "nutrients";

  JsonObject value = doc.createNestedObject("value");
  value["nitrogen"] = nitrogen;
  value["phosphorus"] = phosphorus;
  value["potassium"] = potassium;

  String postData;
  serializeJson(doc, postData);

  HTTPClient http;
  http.begin(serverUrl);
  http.addHeader("Content-Type", "application/json");

  int httpResponseCode = http.POST(postData);

  if (httpResponseCode >= 200 && httpResponseCode < 300) {
    Serial.printf("Nutrient data sent successfully. N: %d, P: %d, K: %d\n", 
                  nitrogen, phosphorus, potassium);
  } else {
    Serial.printf("Error sending nutrient data: %d\n", httpResponseCode);
  }

  http.end();
}

void loop() {
  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();

  if (!isnan(humidity)) {
    sendSensorData("soil_moisture", humidity);
  } else {
    Serial.println("Error reading humidity");
  }

  if (!isnan(temperature)) {
    sendSensorData("soil_temperature", temperature);
  } else {
    Serial.println("Error reading temperature");
  }

  sendNutrientData();

  Serial.println();
  delay(30000);  // Відправляємо дані кожні 30 секунд
}

Код файлу diagram.json:

{
  "version": 1,
  "author": "Іван Шевченко",
  "editor": "wokwi",
  "parts": [
    { "type": "wokwi-esp32-devkit-v1", "id": "esp", "top": 0, "left": 0, "attrs": {} },
    { "type": "wokwi-potentiometer", "id": "pot1", "top": 54.4, "left": -115.2, "attrs": {} },
    { "type": "wokwi-dht22", "id": "dht1", "top": 3.2, "left": 264, "attrs": {} }
  ],
  "connections": [
    [ "esp:TX0", "$serialMonitor:RX", "", [] ],
    [ "esp:RX0", "$serialMonitor:TX", "", [] ],
    [ "dht1:VCC", "esp:3V3", "red", [ "v0" ] ],
    [ "dht1:GND", "esp:GND.1", "black", [ "v0" ] ],
    [ "dht1:SDA", "esp:D21", "green", [ "v0" ] ],
    [ "pot1:GND", "esp:GND.2", "black", [ "v131.33", "h161.07" ] ],
    [ "pot1:VCC", "esp:3V3", "red", [ "v-1.93", "h265.6" ] ],
    [ "pot1:OUT", "esp:D35", "green", [ "v24.51", "h232" ] ]
  ],
  "dependencies": {}
}
 
ДОДАТОК В
Код клієнтської частини


Код файлу App.js:

import React, { useState } from 'react';
import { BrowserRouter as Router, Route, Routes, Link } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button } from '@mui/material';
import { useTranslation } from 'react-i18next';
import Dashboard from './components/Dashboard';
import AdminPanel from './components/AdminPanel';
import Register from './components/Register';
import Login from './components/Login';
import Recommendations from './components/Recommendations';

function App() {
  const { t, i18n } = useTranslation();
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [isAdmin, setIsAdmin] = useState(false);

  const changeLanguage = (lng) => {
    i18n.changeLanguage(lng);
  };

  return (
    <Router>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" style={{ flexGrow: 1 }}>
            {t('appName')}
          </Typography>
          {isLoggedIn && (
            <>
              <Button color="inherit" component={Link} to="/">
                {t('dashboard')}
              </Button>
              <Button color="inherit" component={Link} to="/recommendations">
                {t('recommendations')}
              </Button>
              {isAdmin && (
                <Button color="inherit" component={Link} to="/admin">
                  {t('adminPanel')}
                </Button>
              )}
              <Button color="inherit" onClick={() => {
                localStorage.removeItem('token');
                setIsLoggedIn(false);
                setIsAdmin(false);
              }}>
                {t('logout')}
              </Button>
            </>
          )}
          <Button color="inherit" onClick={() => changeLanguage('en')}>EN</Button>
          <Button color="inherit" onClick={() => changeLanguage('uk')}>UK</Button>
        </Toolbar>
      </AppBar>
      <Routes>
        <Route path="/" element={isLoggedIn ? <Dashboard /> : <Login setIsLoggedIn={setIsLoggedIn} setIsAdmin={setIsAdmin} />} />
        <Route path="/admin" element={isAdmin ? <AdminPanel /> : <Login setIsLoggedIn={setIsLoggedIn} setIsAdmin={setIsAdmin} />} />
        <Route path="/register" element={<Register />} />
        <Route path="/login" element={<Login setIsLoggedIn={setIsLoggedIn} setIsAdmin={setIsAdmin} />} />
        <Route path="/recommendations" element={isLoggedIn ? <Recommendations /> : <Login setIsLoggedIn={setIsLoggedIn} setIsAdmin={setIsAdmin} />} />
      </Routes>
    </Router>
  );
}

export default App;

Код файлу i18n.js:

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

import enTranslations from './locales/en.json';
import ukTranslations from './locales/uk.json';

i18n
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: {
      en: { translation: enTranslations },
      uk: { translation: ukTranslations },
    },
    fallbackLng: 'en',
    debug: true,
    interpolation: {
      escapeValue: false,
    },
  });

export default i18n;

Код файлу AdminPanel.js:

import React from 'react';
import { useTranslation } from 'react-i18next';
import { Grid, Paper, Typography } from '@mui/material';
import UserManagement from './UserManagement';
import DataManagement from './DataManagement';

function AdminPanel() {
  const { t } = useTranslation();

  return (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Typography variant="h4">{t('adminPanel')}</Typography>
      </Grid>
      <Grid item xs={12} md={6}>
        <Paper>
          <UserManagement />
        </Paper>
      </Grid>
      <Grid item xs={12} md={6}>
        <Paper>
          <DataManagement />
        </Paper>
      </Grid>
    </Grid>
  );
}

export default AdminPanel;

Код файлу Dashboard.js:

import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { Grid, Paper, Typography, Select, MenuItem } from '@mui/material';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';
import axios from 'axios';

function Dashboard() {
  const { t } = useTranslation();
  const [sensorData, setSensorData] = useState([]);
  const [selectedSensor, setSelectedSensor] = useState('');
  const [selectedDate, setSelectedDate] = useState('');

  useEffect(() => {
    const fetchData = async () => {
      try {
        const result = await axios.get('http://localhost:3000/api/sensors/data');
        setSensorData(result.data);
        
        if (result.data.length > 0) {
          const dates = [...new Set(result.data.map(data => new Date(data.timestamp).toLocaleDateString()))];
          const latestDate = dates.sort((a, b) => new Date(b) - new Date(a))[0];
          setSelectedDate(latestDate);
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 30000);

    return () => clearInterval(interval);
  }, []);

  const sensorIds = [...new Set(sensorData.map(data => data.sensorId))];
  const dates = [...new Set(sensorData.map(data => new Date(data.timestamp).toLocaleDateString()))];

  const filteredData = sensorData
    .filter(data => !selectedSensor || data.sensorId === selectedSensor)
    .filter(data => new Date(data.timestamp).toLocaleDateString() === selectedDate);

    const prepareChartData = (type, property) => {
      return filteredData
        .filter(d => d.type === type)
        .map(d => ({
          timestamp: new Date(d.timestamp).toLocaleTimeString(),
          value: typeof d.value === 'object' ? d.value[property] : d.value
        }));
    };

  const moistureData = prepareChartData('soil_moisture');
  const temperatureData = prepareChartData('soil_temperature');
  const nitrogenData = prepareChartData('nutrients', 'nitrogen');
  const phosphorusData = prepareChartData('nutrients', 'phosphorus');
  const potassiumData = prepareChartData('nutrients', 'potassium');

  return (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Typography variant="h4">{t('dashboard')}</Typography>
      </Grid>
      <Grid item xs={12}>
        <Select
          value={selectedSensor}
          onChange={e => setSelectedSensor(e.target.value)}
          displayEmpty
        >
          <MenuItem value="">{t('allSensors')}</MenuItem>
          {sensorIds.map(id => (
            <MenuItem key={id} value={id}>{id}</MenuItem>
          ))}
        </Select>
        <Select
          value={selectedDate}
          onChange={e => setSelectedDate(e.target.value)}
        >
          {dates.map(date => (
            <MenuItem key={date} value={date}>{date}</MenuItem>
          ))}
        </Select>
      </Grid>
      <Grid item xs={12} md={6}>
        <Paper>
          <Typography variant="h6">{t('soilMoisture')}</Typography>
          <LineChart width={500} height={300} data={moistureData}>
            <XAxis dataKey="timestamp" />
            <YAxis />
            <CartesianGrid strokeDasharray="3 3" />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="value" stroke="#8884d8" />
          </LineChart>
        </Paper>
      </Grid>
      <Grid item xs={12} md={6}>
        <Paper>
          <Typography variant="h6">{t('soilTemperature')}</Typography>
          <LineChart width={500} height={300} data={temperatureData}>
            <XAxis dataKey="timestamp" />
            <YAxis />
            <CartesianGrid strokeDasharray="3 3" />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="value" stroke="#82ca9d" />
          </LineChart>
        </Paper>
      </Grid>
      <Grid item xs={12} md={4}>
        <Paper>
          <Typography variant="h6">{t('nitrogen')}</Typography>
          <LineChart width={500} height={300} data={nitrogenData}>
            <XAxis dataKey="timestamp" />
            <YAxis />
            <CartesianGrid strokeDasharray="3 3" />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="value" stroke="#8884d8" />
          </LineChart>
        </Paper>
      </Grid>
      <Grid item xs={12} md={4}>
        <Paper>
          <Typography variant="h6">{t('phosphorus')}</Typography>
          <LineChart width={500} height={300} data={phosphorusData}>
            <XAxis dataKey="timestamp" />
            <YAxis />
            <CartesianGrid strokeDasharray="3 3" />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="value" stroke="#82ca9d" />
          </LineChart>
        </Paper>
      </Grid>
      <Grid item xs={12} md={4}>
        <Paper>
          <Typography variant="h6">{t('potassium')}</Typography>
          <LineChart width={500} height={300} data={potassiumData}>
            <XAxis dataKey="timestamp" />
            <YAxis />
            <CartesianGrid strokeDasharray="3 3" />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="value" stroke="#ffc658" />
          </LineChart>
        </Paper>
      </Grid>
    </Grid>
  );
}

export default Dashboard;

Код файлу DataManagement.js:

import React from 'react';
import { useTranslation } from 'react-i18next';
import { Button, Typography } from '@mui/material';
import axios from 'axios';

function DataManagement() {
  const { t } = useTranslation();

  const handleExport = async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/sensors/data/export', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
        responseType: 'blob',
      });

      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', 'data.json');
      document.body.appendChild(link);
      link.click();
    } catch (error) {
      console.error('Error exporting data:', error);
    }
  };

const handleImport = async (event) => {
  const file = event.target.files[0];
  const reader = new FileReader();

  reader.onload = async (e) => {
    const jsonData = JSON.parse(e.target.result);

    try {
      await axios.post('http://localhost:3000/api/sensors/data/import', jsonData, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });

      alert(t('importSuccess'));
    } catch (error) {
      console.error('Error importing data:', error);
      alert(t('importError'));
    }
  };

  reader.readAsText(file);
};

  return (
    <>
      <Typography variant="h6">{t('dataManagement')}</Typography>
      <Button onClick={handleExport}>{t('exportData')}</Button>
      <Button component="label">
        {t('importData')}
        <input type="file" hidden onChange={handleImport} />
      </Button>
    </>
  );
}

export default DataManagement;

Код файлу Login.js:

import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { TextField, Button, Typography, Link } from '@mui/material';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

function Login({ setIsLoggedIn, setIsAdmin }) {
  const { t } = useTranslation();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const response = await axios.post('http://localhost:3000/api/auth/login', { username, password });
      localStorage.setItem('token', response.data.token);
      setIsLoggedIn(true);
      setIsAdmin(response.data.role === 'admin');
      navigate('/');
    } catch (error) {
      alert(t('loginError'));
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Typography variant="h6">{t('login')}</Typography>
      <TextField
        label={t('username')}
        value={username}
        onChange={e => setUsername(e.target.value)}
        required
      />
      <TextField
        type="password"
        label={t('password')}
        value={password}
        onChange={e => setPassword(e.target.value)}
        required
      />
      <Button type="submit">{t('login')}</Button>
      <Typography>
        {t('dontHaveAccount')} <Link href="/register">{t('register')}</Link>
      </Typography>
    </form>
  );
}

export default Login;


Код файлу Recommendations.js:

import React, { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { Grid, Paper, Typography, Select, MenuItem, Button } from '@mui/material';
import axios from 'axios';

function Recommendations() {
  const { t } = useTranslation();
  const [sensorIds, setSensorIds] = useState([]);
  const [crops, setCrops] = useState([]);
  const [selectedSensors, setSelectedSensors] = useState([]);
  const [recommendations, setRecommendations] = useState([]);

  useEffect(() => {
    fetchSensorIds();
    fetchCrops();
    fetchSelectedSensors();
  }, []);

  const fetchRecommendations = useCallback(async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/recommendations', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      setRecommendations(response.data);
    } catch (error) {
      console.error('Error fetching recommendations:', error);
    }
  }, []);

  useEffect(() => {
    fetchRecommendations();
  }, [fetchRecommendations, selectedSensors]);

  const fetchSensorIds = async () => {
  try {
    const response = await axios.get('http://localhost:3000/api/sensors/data');
    const uniqueSensorIds = [...new Set(response.data.map(data => data.sensorId))];
    setSensorIds(uniqueSensorIds);
  } catch (error) {
    console.error('Error fetching sensor IDs:', error);
  }
};

  const fetchCrops = async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/crops');
      setCrops(response.data);
    } catch (error) {
      console.error('Error fetching crops:', error);
    }
  };

  const fetchSelectedSensors = async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/recommendations/selected', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      setSelectedSensors(response.data);
    } catch (error) {
      console.error('Error fetching selected sensors:', error);
    }
  };

  const handleAddSensor = async (sensorId, cropName) => {
    try {
      await axios.post('http://localhost:3000/api/recommendations/selected', { sensorId, cropName }, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      fetchSelectedSensors();
      fetchRecommendations();
    } catch (error) {
      console.error('Error adding sensor:', error);
    }
  };

  const handleRemoveSensor = async (sensorId, cropName) => {
    try {
      await axios.delete(`http://localhost:3000/api/recommendations/selected?sensorId=${sensorId}&cropName=${cropName}`, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      fetchSelectedSensors();
      fetchRecommendations();
    } catch (error) {
      console.error('Error removing sensor:', error);
    }
  };

  const groupRecommendations = (recs) => {
    const grouped = {};
    recs.forEach(rec => {
      const key = `${rec.sensorId}|${rec.cropName}`;
      if (!grouped[key]) {
        grouped[key] = {
          sensorId: rec.sensorId,
          cropName: rec.cropName,
          recommendations: []
        };
      }
      grouped[key].recommendations.push(rec.recommendation);
    });
    return Object.values(grouped);
  };
  
  const translateRecommendation = (recommendation) => {
    const translations = {
      'Water needed:': t('waterNeeded'),
      'Warning:': t('warning'),
      'Add nitrogen fertilizer:': t('addNitrogen'),
      'Add phosphorus fertilizer:': t('addPhosphorus'),
      'Add potassium fertilizer:': t('addPotassium'),
      'soil moisture is': t('soilMoistureIs'),
      'soil temperature is': t('soilTemperatureIs'),
      'optimal for': t('optimalFor'),
      'current': t('current'),
      'required': t('required'),
      'is': t('is'),
    };

    let translatedRec = recommendation;
    Object.entries(translations).forEach(([eng, trans]) => {
      translatedRec = translatedRec.replace(eng, trans);
    });

    return translatedRec;
  };

  return (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Typography variant="h4">{t('recommendations')}</Typography>
      </Grid>
      <Grid item xs={12} md={6}>
        <Paper>
          <Typography variant="h6">{t('addSensor')}</Typography>
          <Select
            value=""
            onChange={(e) => {
              const [sensorId, cropName] = e.target.value.split('|');
              handleAddSensor(sensorId, cropName);
            }}
            displayEmpty
          >
            <MenuItem value="" disabled>{t('selectSensor')}</MenuItem>
            {sensorIds.map((sensorId) => (
              crops.map((crop) => (
                <MenuItem key={`${sensorId}|${crop.name}`} value={`${sensorId}|${crop.name}`}>
                  {sensorId} - {crop.name}
                </MenuItem>
              ))
            ))}
          </Select>
        </Paper>
      </Grid>
      <Grid item xs={12} md={6}>
        <Paper>
          <Typography variant="h6">{t('selectedSensors')}</Typography>
          {selectedSensors.map(({ sensorId, cropName }) => (
            <div key={`${sensorId}|${cropName}`}>
              {sensorId} - {cropName}
              <Button onClick={() => handleRemoveSensor(sensorId, cropName)}>{t('remove')}</Button>
            </div>
          ))}
        </Paper>
      </Grid>
      <Grid item xs={12}>
        <Paper>
          <Typography variant="h6">{t('recommendations')}</Typography>
          {groupRecommendations(recommendations).map(({ sensorId, cropName, recommendations }) => (
            <div key={`${sensorId}|${cropName}`}>
              <Typography variant="subtitle1">{sensorId} - {cropName}</Typography>
              {recommendations.map((recommendation, index) => (
                <Typography key={index}>{translateRecommendation(recommendation)}</Typography>
              ))}
            </div>
          ))}
        </Paper>
      </Grid>
    </Grid>
  );
}

export default Recommendations;

Код файлу Register.js:

import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { TextField, Button, Typography } from '@mui/material';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

function Register() {
  const { t } = useTranslation();
  const [username, setUsername] = useState('');
  const [fullName, setFullName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await axios.post('http://localhost:3000/api/auth/register', { username, fullName, email, password });
      alert(t('registerSuccess'));
      navigate('/login');
    } catch (error) {
      alert(t('registerError'));
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Typography variant="h6">{t('register')}</Typography>
      <TextField
        label={t('username')}
        value={username}
        onChange={e => setUsername(e.target.value)}
        required
      />
      <TextField
        label={t('fullName')}
        value={fullName}
        onChange={e => setFullName(e.target.value)}
        required
      />
      <TextField
        type="email"
        label={t('email')}
        value={email}
        onChange={e => setEmail(e.target.value)}
        required
      />
      <TextField
        type="password"
        label={t('password')}
        value={password}
        onChange={e => setPassword(e.target.value)}
        required
      />
      <Button type="submit">{t('register')}</Button>
    </form>
  );
}

export default Register;

Код файлу UserManagement.js:

import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { List, ListItem, ListItemText, Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from '@mui/material';
import axios from 'axios';

function UserManagement() {
  const { t } = useTranslation();
  const [users, setUsers] = useState([]);
  const [open, setOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState(null);

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      const response = await axios.get('http://localhost:3000/api/users', {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      setUsers(response.data);
    } catch (error) {
      console.error('Error fetching users:', error);
    }
  };

  const handleEditUser = async () => {
    try {
      await axios.put(`http://localhost:3000/api/users/${selectedUser._id}`, selectedUser, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      setOpen(false);
      fetchUsers();
    } catch (error) {
      console.error('Error editing user:', error);
    }
  };

  const handleBanUser = async (userId, banned) => {
    try {
      await axios.put(`http://localhost:3000/api/users/${userId}/${banned ? 'ban' : 'unban'}`, null, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      fetchUsers();
    } catch (error) {
      console.error(`Error ${banned ? 'banning' : 'unbanning'} user:`, error);
    }
  };

  const handleDeleteUser = async (userId) => {
    try {
      await axios.delete(`http://localhost:3000/api/users/${userId}`, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` },
      });
      fetchUsers();
    } catch (error) {
      console.error('Error deleting user:', error);
    }
  };

  return (
    <>
      <List>
        {users.map((user) => (
          <ListItem key={user._id}>
            <ListItemText primary={user.username} secondary={user.email} />
            <Button onClick={() => { setSelectedUser(user); setOpen(true); }}>{t('edit')}</Button>
            <Button onClick={() => handleBanUser(user._id, !user.banned)}>{user.banned ? t('unban') : t('ban')}</Button>
            <Button onClick={() => handleDeleteUser(user._id)}>{t('delete')}</Button>
          </ListItem>
        ))}
      </List>
      <Dialog open={open} onClose={() => setOpen(false)}>
        <DialogTitle>{t('editUser')}</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label={t('username')}
            fullWidth
            value={selectedUser?.username || ''}
            onChange={(e) => setSelectedUser({ ...selectedUser, username: e.target.value })}
          />
          <TextField
            margin="dense"
            label={t('email')}
            fullWidth
            value={selectedUser?.email || ''}
            onChange={(e) => setSelectedUser({ ...selectedUser, email: e.target.value })}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>{t('cancel')}</Button>
          <Button onClick={handleEditUser}>{t('save')}</Button>
        </DialogActions>
      </Dialog>
    </>
  );
}

export default UserManagement;

Код файлу en.json:

{
  "appName": "Farm Monitoring System",
  "dashboard": "Dashboard",
  "adminPanel": "Admin Panel",
  "soilMoisture": "Soil Moisture",
  "soilTemperature": "Soil Temperature",
  "addUser": "Add User",
  "userName": "User Name",
  "cancel": "Cancel",
  "add": "Add",
  "dataManagement": "Data Management",
  "exportData": "Export Data",
  "importData": "Import Data",
  "allSensors": "All Sensors",
  "register": "Register",
  "login": "Login",
  "email": "Email",
  "password": "Password",
  "registerSuccess": "Registration successful",
  "registerError": "Registration failed",
  "loginSuccess": "Login successful",
  "loginError": "Login failed",
  "username": "Username",
  "fullName": "Full Name",
  "dontHaveAccount": "Don't have an account?",
  "edit": "Edit",
  "save": "Save",
  "ban": "Ban",
  "unban": "Unban",
  "delete": "Delete",
  "editUser": "Edit User",
  "importSuccess": "Data imported successfully",
  "importError": "Error importing data",
  "recommendations": "Recommendations",
  "addSensor": "Add Sensor",
  "selectSensor": "Select Sensor",
  "selectedSensors": "Selected Sensors",
  "remove": "Remove",
  "latestData": "Latest Data",
  "moisture": "Moisture",
  "temperature": "Temperature",
  "nitrogen": "Nitrogen",
  "phosphorus": "Phosphorus", 
  "potassium": "Potassium",
  "noSelectedSensors": "No selected sensors",
  "logout": "Log out",
  "waterNeeded": "Water needed:",
  "warning": "Warning:",
  "addNitrogen": "Add nitrogen fertilizer:",
  "addPhosphorus": "Add phosphorus fertilizer:",
  "addPotassium": "Add potassium fertilizer:",
  "soilMoistureIs": "soil moisture is",
  "soilTemperatureIs": "soil temperature is",
  "optimalFor": "optimal for",
  "current": "current",
  "required": "required",
  "is": "is"
}

Код файлу uk.json:

{
  "appName": "Система моніторингу ферми",
  "dashboard": "Панель керування",
  "adminPanel": "Панель адміністратора",
  "soilMoisture": "Вологість ґрунту",
  "soilTemperature": "Температура ґрунту",
  "addUser": "Додати користувача",
  "userName": "Ім'я користувача",
  "cancel": "Скасувати",
  "add": "Додати",
  "dataManagement": "Управління даними",
  "exportData": "Експорт даних",
  "importData": "Імпорт даних",
  "allSensors": "Всі сенсори",
  "register": "Реєстрація",
  "login": "Вхід",
  "email": "Електронна пошта",
  "password": "Пароль",
  "registerSuccess": "Реєстрація успішна",
  "registerError": "Помилка реєстрації",
  "loginSuccess": "Вхід успішний",
  "loginError": "Помилка входу",
  "username": "Ім'я користувача",
  "fullName": "Повне ім'я",
  "dontHaveAccount": "Немає облікового запису?",
  "edit": "Редагувати",
  "save": "Зберегти",
  "ban": "Заблокувати",
  "unban": "Розблокувати",
  "delete": "Видалити",
  "editUser": "Редагувати користувача",
  "importSuccess": "Дані успішно імпортовані",
  "importError": "Помилка імпорту даних",
  "recommendations": "Рекомендації",
  "addSensor": "Додати датчик",
  "selectSensor": "Виберіть датчик",
  "selectedSensors": "Вибрані датчики",
  "remove": "Видалити",
  "latestData": "Останні дані",
  "moisture": "Вологість",
  "temperature": "Температура",
  "nitrogen": "Азот",
  "phosphorus": "Фосфор",
  "potassium": "Калій",
  "noSelectedSensors": "Немає обраних датчиків",
  "logout": "Вийти з акаунту",
  "waterNeeded": "Потрібен полив:",
  "warning": "Попередження:",
  "addNitrogen": "Додайте азотне добриво:",
  "addPhosphorus": "Додайте фосфорне добриво:",
  "addPotassium": "Додайте калійне добриво:",
  "soilMoistureIs": "вологість ґрунту",
  "soilTemperatureIs": "температура ґрунту",
  "optimalFor": "оптимально для",
  "current": "поточне значення",
  "required": "необхідне значення",
  "is": "це"
}
 
ДОДАТОК Г
Результат перевірки на наявність плагіату


 
Рисунок Г.1 – Перевірка на наявність плагіату
